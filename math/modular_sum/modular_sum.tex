\subsection*{Suma modular}

El siguiente algoritmo calcula una multiplicación en módulo minimizando la probabilidad de overflow.
Se puede generalizar para calcular cualquier $a * a * \dots * a$ siendo \textbf{*} una
operación binaria (como $a^b$).

\textit{\textbf{O(log \#terms)}}
\cppfile{math/modular_sum/mulmod.cpp}

El algoritmo consiste en resolver la serie para todas las cantidades
de términos potencias de dos. Se hace logarítmica reutilizando las sumas parciales, aprovechando
la propiedad asociativa ($S(2^n) = S(2^{n-1}) * S(2^{n-1})$), asociando los primeros términos
por un lado y los últimos por el otro. Tomamos las potencias de dos que forman la cantidad de
términos, y los combinamos entre sí para obtener el resultado total. Y en cada paso tomamos
módulo.

El snippet que viene es una adaptación del algoritmo a un problema de combinatoria de la
\textit{Sub-Regional Brasil 2013}.

\cppfile{math/modular_sum/combmod.cpp}