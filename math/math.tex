\section{Math}

\subsection*{Suma modular}

El siguiente algoritmo calcula una multiplicación en módulo minimizando la probabilidad de overflow.

\textit{\textbf{O(log \#terms)}}
\cppfile{math/module_operations/mulmod.cpp}

Se puede generalizar para calcular \textit{a * a * ... * a} siendo \textbf{*} una operación binaria
arbitraria. El algoritmo consiste en resolver la serie para todas las cantidades
de términos potencias de dos. Se hace logarítmica reutilizando las sumas parciales, aprovechando
la propiedad asociativa ($S(2^n) = S(2^{n-1}) * S(2^{n-1})$), asociando los primeros términos
por un lado y los últimos por el otro. Tomamos las potencias de dos que forman la cantidad de
términos, y los combinamos entre sí para obtener el resultado total. Y en cada paso tomamos
módulo.

El snippet que viene es una adaptación del algoritmo a un problema de combinatoria de la
\textit{Sub-Regional Brasil 2013}.

\cppfile{math/module_operations/combmod.cpp}


\subsection*{Raices de polinomio}

\begin{equation*}
    a^2 + bx + c = 0 \; \Longleftrightarrow \; x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\end{equation*}