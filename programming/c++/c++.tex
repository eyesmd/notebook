
\subsection{Misc}

\subsubsection*{Input}

\begin{lstlisting}
getline(cin, s); // reads line from input into 's'
\end{lstlisting}

\subsubsection*{Strings}

\begin{lstlisting}
s.substr(i, len); // returns s[i..i+len], or s[i..] if i+len >= sz(s)
\end{lstlisting}

\subsubsection*{Containers}

\begin{lstlisting}
vector<int> v( all(c) );
set<int> s( all(c) );
\end{lstlisting}


\subsubsection*{Permutaciones}

\textit{Next permutation} muta un container a la permutación inmediata superior, y retorna si quedó ordenado. El siguiente snippet utiliza dicha función para \textbf{recorrer en orden} todas las permutaciones de un arreglo/vector \textbf{ya ordenado}:

\begin{lstlisting}
vector<int> v;
sort(v.begin(), v.end());
do {
    // code
} while (next_permutation(v.begin(), v.end()));  #\amortizedohk{n!}#
\end{lstlisting}

La guarda está al final para que el cuerpo del ciclo corra al menos una vez con el vector ordenado (porque la condición de corte es justamente si está ordenado).

\subsubsection*{Repetidos}
\begin{lstlisting}
set<int> s( vec.begin(), vec.end() );
vec.assign( s.begin(), s.end() );
\end{lstlisting}

\subsubsection*{Punteros}

\begin{itemize}
    \item ¡Los punteros son considerados \textit{random-access iterators}! Esto implica que todos los algoritmos de la STL los podemos utilizar sobre arrays (por ejemplo, \textit{sort(arr, arr+n)}).
    \item Los arrays 'decaen' a punteros en casi todas sus operaciones (son excepciones \textit{sizeof} y \textit{\&}). Un ejemplo notable es cuando son pasados como argumentos de funciones, razón por la cual los programas siguen tipando, aún cuando le pasamos un array a una función que espera un puntero (obs: sin embargo, sí fallaría si pasásemos un array de arrays).
\end{itemize}

\subsubsection*{Recordatorios}

\begin{itemize}
    \item ¡Para usar un \textit{unordered\_set} hace falta implementar una función de hash para pares!
    \item \textit{std::find} para sets es O(n) porque es genérico, lo que es O(log n) es \textit{std::set::find}
    \item El operador [] para maps crea un elemento si no lo encuentra, \textit{at} en cambio tira una excepción
    \item ¡El operador módulo devuelve negativos!
\end{itemize}
